# Identify: 
The code is in a rough shape; it is cobbled together, making it hard to work with. We need to be able to add to and expand our code, starting with autonomous and color sensing.
# Brainstorm: 
Honestly, we could just deal with the code. It is a little buggy and it is very messy, but it functions. We could instead clean it up. This would take some time, but it would make the code less buggy and easier to add to. We could also just completely rewrite the code. This would take the longest, but it also has the most benefits. ​
# Select:
I chose to rewrite the code. This has many advantages: The code will be very clean and organized, I can avoid or solve problems we had with the old code, I could add and expand our code more easily, and importantly, it would also mean we could change development environments. We have been using VexCode through Visual Studio Code up until now, but we will be changing to PROS. PROS is open source, more comprehensive, and well maintained. These qualities and more make it a better choice than the VexCode development environment. PROS also has better library support. Some of these libraries are made for autonomous, which we feel like could help us when we add an autonomous.​
# Implement: 
I rewrote all of the functionality we had in VexCode in PROS instead. I also made many improvements. The main improvement fixed how some of our button inputs are handled. On the old code, all the button inputs were handled differently than normal; they would do a “toggle hold”. A “hold” button performs an action for as long as you hold the button, while a “toggle” button performs the action when you press the button, then stops the next time you press the button. Our “toggle hold” buttons were a combination of both strategies with a threshold to decide whether the press was a “toggle” or a “hold”. We had all the buttons set up this way when we wrote the code. But we then changed a few of the to the more normal button approaches later during a competition because “toggle hold” was not as useful for some of our functions. In the new code, I made a header file that handles this better. We start by defining a button state for the button we want to use, e.g., TOGGLE, HOLD, or TOGGLE_HOLD. Then, every cycle of the main loop, we tell the code the current state of the button; on or off. It takes that input, the previous state, and the button type and then returns true if the function should be active, or false if it should not be active. This make the code much cleaner and organized. It also makes it very easy to add another button in later.​
# Test: 
Almost all the code I added worked perfectly, including the new header. However, the drivetrain controls were backwards; easy fix. I reversed the directions of the motors.


	Linus 11/03/2025